<!DOCTYPE html>
<!-- https://tellusim.com/mesh-shader-emulation -->
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Learning WebGPU</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        background-color: darkgray;
        margin: 0px;
      }
    </style>
  </head>
  <body>
    <canvas id="target" width="720" height="380"></canvas>
    <script>
      const canvasId = "target";
      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById(canvasId);
      if (canvas === null || !(canvas instanceof HTMLCanvasElement))
        throw new Error(
          `Could not find a canvas with element id '${canvasId}'.`
        );
    </script>
    <script type="module">
      import {
        initialization,
        createMeshBuffers,
        createMainPipeline,
      } from "/index.js";
      import {
        vec3,
        mat4,
      } from "https://wgpu-matrix.org/dist/2.x/wgpu-matrix.module.js";

      const [device, context, format] = await initialization(canvas);

      const encoder = device.createCommandEncoder({
        label: "main-command-encoder",
      });
      const currentTexture = context.getCurrentTexture();
      const currentTextureView = currentTexture.createView({
        label: "current-texture-view",
      });

      const vertexData = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      const indexData = new Uint16Array([0, 1, 2, 2, 1, 3]);

      const meshBuffers = createMeshBuffers(
        device,
        vertexData.byteLength,
        indexData.byteLength
      );

      device.queue.writeBuffer(meshBuffers.vertexBuffer, 0, vertexData);
      device.queue.writeBuffer(meshBuffers.indexBuffer, 0, indexData);

      const sizeOfFloat32 = 4;

      const mainUniformBuffer = device.createBuffer({
        label: "main-uniform-buffer",
        size: sizeOfFloat32 * 4 * 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      const perspective = mat4.perspective(
        (80 * Math.PI) / 180,
        canvas.width / canvas.height,
        0.1,
        1000
      );

      {
        const view = mat4.lookAt([-0.2, -1, 1], [0, 0, 0], [0, 0, 1]);
        const cameraBufferData = mat4.multiply(perspective, view);
        device.queue.writeBuffer(mainUniformBuffer, 0, cameraBufferData);
      }

      const mainPipeline = createMainPipeline(device, format);

      const mainBindGroup = device.createBindGroup({
        label: "main-bind-group",
        layout: mainPipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer: mainUniformBuffer } }],
      });

      const mainRenderPass = encoder.beginRenderPass({
        label: "main-render-pass",
        colorAttachments: [
          {
            view: currentTextureView,
            loadOp: "clear",
            clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1 },
            storeOp: "store",
          },
        ],
      });

      mainRenderPass.setPipeline(mainPipeline);
      mainRenderPass.setVertexBuffer(0, meshBuffers.vertexBuffer);
      mainRenderPass.setIndexBuffer(meshBuffers.indexBuffer, "uint16");
      mainRenderPass.setBindGroup(0, mainBindGroup);
      mainRenderPass.drawIndexed(6);

      mainRenderPass.end();

      device.queue.submit([
        encoder.finish({
          label: "main-render-command-buffer",
        }),
      ]);
    </script>
  </body>
</html>
