<!DOCTYPE html>
<!-- https://tellusim.com/mesh-shader-emulation -->
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Learning WebGPU</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        background-color: darkgray;
        margin: 0px;
      }
    </style>
  </head>
  <body>
    <canvas id="target" width="720" height="380"></canvas>
    <script type="module">
      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById("target");
      import { initialization, createMeshBuffers } from "/index.js";

      const [device, context, format] = await initialization(canvas);

      const encoder = device.createCommandEncoder({
        label: "main-command-encoder",
      });
      const currentTexture = context.getCurrentTexture();
      const currentTextureView = currentTexture.createView({
        label: "current-texture-view",
      });

      const vertexData = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      const indexData = new Uint16Array([0, 1, 2, 2, 1, 3]);

      const meshBuffers = createMeshBuffers(
        device,
        vertexData.byteLength,
        indexData.byteLength
      );

      device.queue.writeBuffer(meshBuffers.vertexBuffer, 0, vertexData);
      device.queue.writeBuffer(meshBuffers.indexBuffer, 0, indexData);

      const sizeOfFloat32 = 4;

      const vertexBufferLayout = {
        arrayStride: sizeOfFloat32 * 2,
        attributes: [
          {
            format: "float32x2",
            offset: 0,
            shaderLocation: 0,
          },
        ],
      };

      const mainShaderCode = `
        struct VsInput {
          @location(0) position: vec2f,
        };

        struct VsOutput {
          @builtin(position) position: vec4f,
        };

        @vertex
        fn vertexShader(vsIn: VsInput) -> VsOutput {
          var vsOut: VsOutput;
          vsOut.position = vec4f(vsIn.position, 0, 1);
          return vsOut;
        }
        
        @fragment
        fn fragmentShader(vsOut: VsOutput) -> @location(0) vec4f {
          return vec4f(1, 0, 0, 1);
        }`;

      const mainShaderModule = device.createShaderModule({
        label: "main-shader",
        code: mainShaderCode,
      });

      const mainPipeline = device.createRenderPipeline({
        label: "main-pipeline",
        layout: "auto",
        vertex: {
          module: mainShaderModule,
          entryPoint: "vertexShader",
          buffers: [vertexBufferLayout],
        },
        fragment: {
          module: mainShaderModule,
          entryPoint: "fragmentShader",
          targets: [{ format }],
        },
      });

      const mainRenderPass = encoder.beginRenderPass({
        label: "main-render-pass",
        colorAttachments: [
          {
            view: currentTextureView,
            loadOp: "clear",
            clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1 },
            storeOp: "store",
          },
        ],
      });
      mainRenderPass.end();
      device.queue.submit([
        encoder.finish({
          label: "main-render-command-buffer",
        }),
      ]);
    </script>
  </body>
</html>
